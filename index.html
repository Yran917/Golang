<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹ (Gomoku) ğŸ®</title>
    <style>
        /* ------------------- CSS æ ·å¼ ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* æµ…ç°è‰²èƒŒæ™¯ */
            color: #333;
            flex-direction: column;
        }

        header {
            margin-bottom: 20px;
            text-align: center;
            color: #2c3e50;
        }

        .game-container {
            display: flex;
            background-color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            overflow: hidden;
            max-width: 1000px;
        }

        /* æ£‹ç›˜åŒºåŸŸ */
        .board-area {
            padding: 20px;
            background-color: #e0ac69; /* ç»å…¸æ£‹ç›˜æœ¨çº¹è‰² */
            position: relative;
        }

        /* æ£‹ç›˜ç”»å¸ƒ */
        #gomoku-board {
            border: 1px solid #000;
            cursor: pointer;
            display: block;
            background-color: #e0ac69;
        }

        /* ä¾§è¾¹æ§åˆ¶é¢æ¿ */
        .control-panel {
            width: 280px;
            padding: 30px;
            background-color: #2c3e50; /* æ·±è‰²èƒŒæ™¯ */
            color: #ecf0f1; /* æµ…è‰²æ–‡å­— */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .section h3 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #3498db;
        }

        /* æŒ‰é’®æ ·å¼ */
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.1s;
            width: 100%;
        }

        button:hover {
            background-color: #2980b9;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        /* æ¨¡å¼å’Œéš¾åº¦é€‰æ‹© */
        select {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            background-color: #ecf0f1;
            color: #333;
        }

        /* çŠ¶æ€ä¿¡æ¯ */
        .status-info p {
            margin: 8px 0;
            font-size: 1.1em;
        }

        .status-info strong {
            color: #f1c40f;
        }

        #timer {
            font-size: 1.5em;
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }

        /* å¼¹å‡ºå±‚/èƒœåˆ©ä¿¡æ¯ */
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* é»˜è®¤éšè— */
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            color: #333;
        }

        .modal-content h2 {
            color: #e74c3c;
            margin-bottom: 10px;
        }

        .modal-content button {
            margin-top: 20px;
            width: auto;
            padding: 10px 25px;
        }

        /* æœ€åçš„è½å­æ ‡è®° */
        .last-move-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #e74c3c; /* çº¢è‰² */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* ä¸å½±å“ç‚¹å‡» */
        }
    </style>
</head>
<body>

    <header>
        <h1>äº”å­æ£‹ (Gomoku) ç»å…¸ç‰ˆ</h1>
    </header>

    <div class="game-container">
        <div class="board-area">
            <canvas id="gomoku-board" width="600" height="600"></canvas>
            <div id="last-move-marker" class="last-move-marker" style="display: none;"></div>
        </div>

        <div class="control-panel">
            <div>
                <div class="section">
                    <h3>è®¾ç½®</h3>
                    <label for="game-mode">é€‰æ‹©æ¨¡å¼ï¼š</label>
                    <select id="game-mode">
                        <option value="pve">äººæœºå¯¹æˆ˜ (PVE)</option>
                        <option value="pvp">äººäººå¯¹æˆ˜ (PVP)</option>
                    </select>

                    <label for="ai-difficulty" id="ai-difficulty-label">AI éš¾åº¦ï¼š</label>
                    <select id="ai-difficulty">
                        <option value="easy">ç®€å•</option>
                        <option value="medium">ä¸€èˆ¬</option>
                        <option value="hard">å›°éš¾</option>
                    </select>
                </div>

                <div class="section">
                    <h3>æ“ä½œ</h3>
                    <button id="start-btn">å¼€å§‹æ¸¸æˆ / é‡æ–°å¼€å§‹</button>
                    <button id="undo-btn" disabled>æ‚”æ£‹ (Undo)</button>
                </div>
            </div>

            <div class="section status-info">
                <h3>çŠ¶æ€</h3>
                <div id="timer">00:00</div>
                <p>å½“å‰ç©å®¶: <strong id="current-player">é»‘å­ (Black)</strong></p>
                <p>è½å­ä½ç½®: <strong id="last-position">N/A</strong></p>
                <p>æ¸¸æˆçŠ¶æ€: <strong id="game-status">æœªå¼€å§‹</strong></p>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-message"></h2>
            <p>ç”¨æ—¶: <span id="modal-time"></span></p>
            <button id="close-modal-btn">å¥½çš„ï¼Œå†æ¥ä¸€å±€</button>
        </div>
    </div>


    <script>
        // ------------------- JavaScript æ¸¸æˆé€»è¾‘ -------------------
        const BOARD_SIZE = 15; // æ£‹ç›˜å¤§å° 15x15
        const CELL_SIZE = 40;  // æ£‹ç›˜æ ¼å­å¤§å° (600 / 15 = 40)

        const canvas = document.getElementById('gomoku-board');
        const ctx = canvas.getContext('2d');
        const undoBtn = document.getElementById('undo-btn');
        const startBtn = document.getElementById('start-btn');
        const gameModeSelect = document.getElementById('game-mode');
        const aiDifficultySelect = document.getElementById('ai-difficulty');
        const aiDifficultyLabel = document.getElementById('ai-difficulty-label');
        const currentPlayerSpan = document.getElementById('current-player');
        const lastPositionSpan = document.getElementById('last-position');
        const gameStatusSpan = document.getElementById('game-status');
        const lastMoveMarker = document.getElementById('last-move-marker');
        const timerDisplay = document.getElementById('timer');

        let board = [];
        let currentPlayer = 1; // 1: é»‘å­ (Black), 2: ç™½å­ (White)
        let isGameOver = true;
        let moveHistory = []; // å­˜å‚¨è½å­å†å²: [{x, y, player}]
        let timerInterval;
        let startTime;

        // --- åˆå§‹åŒ–æ£‹ç›˜ ---
        function initBoard() {
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            moveHistory = [];
            currentPlayer = 1;
            isGameOver = false;
            undoBtn.disabled = true;
            lastPositionSpan.textContent = 'N/A';
            gameStatusSpan.textContent = 'æ¸¸æˆä¸­...';
            updateCurrentPlayerDisplay();
            drawBoard();
            stopTimer();
            timerDisplay.textContent = '00:00';

            // æ£€æŸ¥AIéš¾åº¦é€‰æ‹©çš„å¯è§æ€§
            const isPVE = gameModeSelect.value === 'pve';
            aiDifficultySelect.style.display = isPVE ? 'block' : 'none';
            aiDifficultyLabel.style.display = isPVE ? 'block' : 'none';

            if (isPVE && currentPlayer === 2) {
                // å¦‚æœPVEæ¨¡å¼ä¸‹ç™½å­å…ˆæ‰‹ï¼Œåˆ™AIå…ˆä¸‹ (è¿™é‡Œé»˜è®¤é»‘å­å…ˆæ‰‹ï¼Œæ‰€ä»¥é€šå¸¸ä¸éœ€è¦)
            }
        }

        // --- ç»˜åˆ¶æ£‹ç›˜å’Œæ£‹å­ ---
        function drawBoard() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶çº¿æ¡
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for (let i = 0; i < BOARD_SIZE; i++) {
                // å‚ç›´çº¿
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE / 2 + i * CELL_SIZE, CELL_SIZE / 2);
                ctx.lineTo(CELL_SIZE / 2 + i * CELL_SIZE, canvas.height - CELL_SIZE / 2);
                ctx.stroke();

                // æ°´å¹³çº¿
                ctx.beginPath();
                ctx.moveTo(CELL_SIZE / 2, CELL_SIZE / 2 + i * CELL_SIZE);
                ctx.lineTo(canvas.width - CELL_SIZE / 2, CELL_SIZE / 2 + i * CELL_SIZE);
                ctx.stroke();
            }

            // ç»˜åˆ¶æ˜Ÿä½ (å¤©å…ƒåŠå››ä¸ªè§’)
            const starPoints = [
                {x: 3, y: 3}, {x: 11, y: 3},
                {x: 3, y: 11}, {x: 11, y: 11},
                {x: 7, y: 7} // å¤©å…ƒ
            ];
            ctx.fillStyle = '#000000';
            starPoints.forEach(p => {
                const cx = CELL_SIZE / 2 + p.x * CELL_SIZE;
                const cy = CELL_SIZE / 2 + p.y * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // ç»˜åˆ¶æ£‹å­
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        drawPiece(i, j, board[i][j]);
                    }
                }
            }
        }

        // ç»˜åˆ¶å•ä¸ªæ£‹å­
        function drawPiece(x, y, player) {
            const cx = CELL_SIZE / 2 + x * CELL_SIZE;
            const cy = CELL_SIZE / 2 + y * CELL_SIZE;
            const color = player === 1 ? 'black' : 'white';

            ctx.beginPath();
            ctx.arc(cx, cy, CELL_SIZE * 0.45, 0, Math.PI * 2);

            // å¢åŠ æ¸å˜æ•ˆæœï¼Œä½¿æ£‹å­æ›´ç«‹ä½“
            const gradient = ctx.createRadialGradient(
                cx - CELL_SIZE * 0.1, cy - CELL_SIZE * 0.1, CELL_SIZE * 0.1,
                cx, cy, CELL_SIZE * 0.45
            );
            if (player === 1) { // é»‘å­
                gradient.addColorStop(0, '#555555');
                gradient.addColorStop(1, '#000000');
            } else { // ç™½å­
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, '#cccccc');
            }

            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- è½å­å¤„ç† ---
        function placePiece(x, y) {
            if (isGameOver || board[x][y] !== 0) {
                return false;
            }

            // 1. è®°å½•è½å­
            board[x][y] = currentPlayer;
            moveHistory.push({x, y, player: currentPlayer});

            // 2. ç»˜åˆ¶å’Œæ›´æ–°çŠ¶æ€
            drawBoard(); // é‡æ–°ç»˜åˆ¶ä»¥ç¡®ä¿æœ€æ–°çš„æ£‹å­å’Œæ ‡è®°æ˜¾ç¤º
            updateLastMoveMarker(x, y); // æ ‡è®°æœ€åçš„è½å­ä½ç½®
            updateLastPositionDisplay(x, y);

            // 3. æ£€æŸ¥èƒœåˆ©
            if (checkWin(x, y, currentPlayer)) {
                gameOver(currentPlayer);
                return true;
            }

            // 4. åˆ‡æ¢ç©å®¶
            switchPlayer();
            
            // 5. å¯ç”¨æ‚”æ£‹
            undoBtn.disabled = false;

            // 6. å¦‚æœæ˜¯äººæœºå¯¹æˆ˜ï¼Œè§¦å‘ AI ä¸‹æ£‹
            if (gameModeSelect.value === 'pve' && currentPlayer === 2) { // å‡è®¾AIæ˜¯ç™½å­
                // ç«‹å³ç¦ç”¨è½å­ï¼Œç­‰å¾…AIä¸‹å®Œ
                canvas.style.pointerEvents = 'none';
                setTimeout(aiMove, 500); // å¢åŠ å»¶è¿Ÿï¼Œæ¨¡æ‹Ÿæ€è€ƒæ—¶é—´ï¼Œæé«˜äº¤äº’æ€§
            } else {
                canvas.style.pointerEvents = 'auto';
            }

            return true;
        }

        // --- åˆ‡æ¢ç©å®¶ ---
        function switchPlayer() {
            currentPlayer = 3 - currentPlayer; // 1 -> 2, 2 -> 1
            updateCurrentPlayerDisplay();
        }

        // --- æ£€æŸ¥èƒœåˆ©æ¡ä»¶ ---
        function checkWin(x, y, player) {
            const directions = [
                [1, 0],  // æ°´å¹³
                [0, 1],  // å‚ç›´
                [1, 1],  // ä¸»å¯¹è§’çº¿
                [1, -1]  // å‰¯å¯¹è§’çº¿
            ];

            for (const [dx, dy] of directions) {
                let count = 1; // åŒ…å«å½“å‰è½å­

                // æ£€æŸ¥ä¸€ä¸ªæ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === player) {
                        count++;
                    } else {
                        break;
                    }
                }

                // æ£€æŸ¥ç›¸åæ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === player) {
                        count++;
                    } else {
                        break;
                    }
                }

                if (count >= 5) {
                    return true;
                }
            }

            return false;
        }

        // --- æ¸¸æˆç»“æŸ ---
        function gameOver(winner) {
            isGameOver = true;
            stopTimer();
            canvas.style.pointerEvents = 'none';
            gameStatusSpan.textContent = 'æ¸¸æˆç»“æŸï¼';

            const winnerText = winner === 1 ? 'é»‘å­ (Black)' : 'ç™½å­ (White)';
            const message = `æ­å–œ ${winnerText} è·èƒœï¼`;
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            const totalTime = formatTime(new Date() - startTime);
            document.getElementById('modal-message').textContent = message;
            document.getElementById('modal-time').textContent = totalTime;
            document.getElementById('modal').style.display = 'flex';
        }

        // --- æ‚”æ£‹åŠŸèƒ½ ---
        function undoMove() {
            if (isGameOver || moveHistory.length === 0) {
                return;
            }

            const isPVE = gameModeSelect.value === 'pve';
            
            if (isPVE) {
                // PVE æ¨¡å¼ä¸‹ï¼Œæ‚”æ£‹éœ€è¦ç§»é™¤æœ€åä¸¤æ­¥ (äººä¸‹çš„ä¸€æ­¥å’Œ AI ä¸‹çš„ä¸€æ­¥)
                if (moveHistory.length < 2) return;
                
                // ç§»é™¤ AI çš„ä¸€æ­¥ (ç™½å­)
                let lastMove = moveHistory.pop();
                board[lastMove.x][lastMove.y] = 0;
                
                // ç§»é™¤ç©å®¶çš„ä¸€æ­¥ (é»‘å­)
                lastMove = moveHistory.pop();
                board[lastMove.x][lastMove.y] = 0;

                currentPlayer = 1; // å›åˆ°ç©å®¶ (é»‘å­)
                canvas.style.pointerEvents = 'auto'; // å…è®¸ç©å®¶ä¸‹æ£‹
            } else {
                // PVP æ¨¡å¼ä¸‹ï¼Œæ‚”æ£‹ç§»é™¤ä¸€æ­¥ï¼Œåˆ‡æ¢å›å‰ä¸€ä¸ªç©å®¶
                const lastMove = moveHistory.pop();
                board[lastMove.x][lastMove.y] = 0;
                
                switchPlayer(); // åˆ‡æ¢å›ä¸Šä¸€ä¸ªç©å®¶
            }

            drawBoard();
            undoBtn.disabled = moveHistory.length === 0;

            // æ›´æ–°æœ€åçš„è½å­æ ‡è®°å’Œä½ç½®æ˜¾ç¤º
            if (moveHistory.length > 0) {
                const last = moveHistory[moveHistory.length - 1];
                updateLastMoveMarker(last.x, last.y);
                updateLastPositionDisplay(last.x, last.y);
            } else {
                lastMoveMarker.style.display = 'none';
                lastPositionSpan.textContent = 'N/A';
            }
        }

        // --- AI é€»è¾‘ (æç®€/ç®€å•å®ç°ï¼Œä¸ä½¿ç”¨ Alpha-Beta å‰ªæï¼Œç¡®ä¿é€Ÿåº¦) ---
        function aiMove() {
            let bestMove = null;
            let bestScore = -Infinity;
            const difficulty = aiDifficultySelect.value;
            let depth = 0; // æœç´¢æ·±åº¦

            switch (difficulty) {
                case 'easy':
                    depth = 1; // åªè€ƒè™‘ä¸‹ä¸€æ­¥ (éšæœºæˆ–ç®€å•é˜»å¡)
                    break;
                case 'medium':
                    depth = 2; // è€ƒè™‘ä¸¤æ­¥ï¼ŒåŸºæœ¬çš„æ”»é˜²
                    break;
                case 'hard':
                    depth = 3; // è€ƒè™‘ä¸‰æ­¥ï¼Œæ›´å¤æ‚çš„æ”»é˜²ï¼Œä½†ä»è¾ƒå¿«
                    break;
            }

            // åœ¨å®é™…çš„äº”å­æ£‹ä¸­ï¼Œdepth=3-5æ‰èƒ½æä¾›å¥½çš„ä½“éªŒï¼Œè¿™é‡Œä¸ºäº†ä¿æŒé€Ÿåº¦ï¼Œæˆ‘ä»¬é™åˆ¶æ·±åº¦ï¼Œ
            // å¹¶ä½¿ç”¨ç®€å•çš„è¯„åˆ†å‡½æ•°ã€‚

            // 1. å°è¯•ç›´æ¥èƒœåˆ©å’Œé˜»å¡å¯¹æ‰‹
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] === 0) {
                        // 1a. å°è¯•è‡ªå·±èƒœåˆ© (ç™½å­)
                        board[i][j] = 2;
                        if (checkWin(i, j, 2)) {
                            board[i][j] = 0;
                            placePiece(i, j); // ç«‹å³ä¸‹å­
                            return;
                        }
                        board[i][j] = 0;

                        // 1b. å°è¯•é˜»å¡å¯¹æ‰‹èƒœåˆ© (é»‘å­)
                        board[i][j] = 1;
                        if (checkWin(i, j, 1)) {
                            board[i][j] = 0;
                            placePiece(i, j); // ç«‹å³ä¸‹å­
                            return;
                        }
                        board[i][j] = 0;
                    }
                }
            }

            // 2. ä½¿ç”¨ Minimax æœç´¢ (ç®€åŒ–ç‰ˆï¼Œä»…è¯„ä¼°å½“å‰å±€é¢)
            
            // ä»…å¯¹éç©ºå­é™„è¿‘çš„æ ¼å­è¿›è¡Œè¯„ä¼°ï¼Œå‡å°‘æœç´¢èŒƒå›´
            const candidateMoves = getCandidateMoves(depth);

            for (const move of candidateMoves) {
                const { x, y } = move;
                
                // æ¨¡æ‹Ÿä¸‹å­
                board[x][y] = 2;
                let score = evaluateBoard(); // è¯„ä¼°å½“å‰å±€é¢
                
                // å¦‚æœæ˜¯medium/hardï¼Œè€ƒè™‘ä¸‹ä¸€è½®å¯¹æ‰‹çš„æœ€ä½³åº”å¯¹ (Minimax)
                if (depth > 1) {
                    let opponentBestScore = Infinity;
                    const nextCandidateMoves = getCandidateMoves(1); // è¯„ä¼°ä¸‹ä¸€è½®å¯¹æ‰‹çš„å€™é€‰ç‚¹
                    
                    for (const nextMove of nextCandidateMoves) {
                        // æ¨¡æ‹Ÿå¯¹æ‰‹ä¸‹å­
                        board[nextMove.x][nextMove.y] = 1;
                        // è¿™é‡Œåªæ˜¯ç®€å•åœ°è¯„ä¼°å¯¹æ‰‹ä¸‹å­åçš„å±€é¢ï¼Œå¹¶å–æœ€å° (å› ä¸ºå¯¹æ‰‹ä¼šæœ€å°åŒ–AIçš„åˆ†æ•°)
                        const opponentScore = evaluateBoard(); 
                        board[nextMove.x][nextMove.y] = 0; // æ’¤é”€å¯¹æ‰‹ä¸‹å­

                        opponentBestScore = Math.min(opponentBestScore, opponentScore);
                    }
                    // æœ€ç»ˆè¯„åˆ† = è‡ªå·±çš„åˆ†æ•° - å¯¹æ‰‹èƒ½é€ æˆçš„æœ€å°åˆ†æ•°
                    score = score - opponentBestScore * 0.5; // åŠ ä¸Šä¸€ä¸ªç³»æ•°ï¼Œé˜²æ­¢AIè¿‡äºä¿å®ˆ
                }

                board[x][y] = 0; // æ’¤é”€ä¸‹å­

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            // 3. éšæœºé€‰æ‹© (å¦‚æœæœç´¢æ²¡æœ‰æ‰¾åˆ°ä»»ä½•ç‚¹)
            if (!bestMove) {
                const emptyCells = [];
                 for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 0) {
                            emptyCells.push({x: i, y: j});
                        }
                    }
                }
                if (emptyCells.length > 0) {
                    bestMove = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                } else {
                    // å¹³å±€
                    return;
                }
            }

            placePiece(bestMove.x, bestMove.y);
        }

        // --- AI è¾…åŠ©ï¼šè·å–å€™é€‰è½å­ç‚¹ (éç©ºå­å‘¨å›´ 2 æ ¼èŒƒå›´å†…) ---
        function getCandidateMoves(range) {
            const candidates = new Set();
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        for (let dx = -range; dx <= range; dx++) {
                            for (let dy = -range; dy <= range; dy++) {
                                const nx = i + dx;
                                const ny = j + dy;
                                if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === 0) {
                                    candidates.add(`${nx},${ny}`);
                                }
                            }
                        }
                    }
                }
            }
            // å¦‚æœæ²¡æœ‰æ£‹å­ï¼Œåˆ™é»˜è®¤å¤©å…ƒ
            if (candidates.size === 0) {
                candidates.add('7,7');
            }
            return Array.from(candidates).map(c => {
                const [x, y] = c.split(',').map(Number);
                return {x, y};
            });
        }

        // --- AI è¾…åŠ©ï¼šç®€å•å±€é¢è¯„ä¼°å‡½æ•° ---
        // æ ¸å¿ƒæ€è·¯ï¼šè¯„ä¼°ç™½å­ (AI, player 2) çš„è¿å­å’Œé»‘å­ (Player, player 1) çš„è¿å­ï¼Œ
        // å¹¶ç»™äºˆè¿5ã€æ´»4ã€æ­»4ã€æ´»3ã€æ­»3ç­‰ä¸åŒçš„åˆ†æ•°æƒé‡ã€‚
        function evaluateBoard() {
            let score = 0;
            const SCORE_WEIGHTS = {
                '5': 100000,   // è¿5 (å¿…èƒœ)
                'æ´»4': 50000, // æ´»4
                'å†²4': 1000,  // å†²4 (æ­»4)
                'æ´»3': 500,   // æ´»3
                'çœ 3': 10,    // çœ 3 (æ­»3)
                'æ´»2': 5,     // æ´»2
                'çœ 2': 1,     // çœ 2
            };

            // æ£‹ç›˜ä¸Šæ¯ä¸€ç‚¹ï¼Œæ£€æŸ¥æ‰€æœ‰æ–¹å‘
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (board[i][j] !== 0) {
                        score += evaluatePoint(i, j, board[i][j], SCORE_WEIGHTS);
                    }
                }
            }

            return score;
        }

        // è¯„ä¼°å•ä¸ªç‚¹åœ¨æ‰€æœ‰æ–¹å‘ä¸Šçš„ä»·å€¼ (ç®€åŒ–ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„æœç´¢)
        function evaluatePoint(x, y, player, weights) {
            let pointScore = 0;
            const directions = [[1, 0], [0, 1], [1, 1], [1, -1]];
            const opponent = 3 - player;
            
            // æ£€æŸ¥æ¯ä¸ªæ–¹å‘ (æ°´å¹³ã€å‚ç›´ã€ä¸¤æ¡å¯¹è§’çº¿)
            for (const [dx, dy] of directions) {
                // æ£€æŸ¥è¿™ä¸ªæ–¹å‘ä¸Šæ˜¯å¦æœ‰æ´»/å†²è¿å­
                // è¿™æ˜¯ä¸€ä¸ªéå¸¸ç®€åŒ–çš„è¯„ä¼°ï¼Œå®é™… Gomoku AI ä¼šç”¨æ¨¡å¼åŒ¹é…
                
                let count = 0;
                let openEnds = 0; // ä¸¤ç«¯æ˜¯å¦å¼€æ”¾

                // æ­£æ–¹å‘å»¶ä¼¸
                let tempCount = 0;
                for (let k = 1; k < 5; k++) {
                    const nx = x + k * dx;
                    const ny = y + k * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === player) {
                        tempCount++;
                    } else if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === 0) {
                        openEnds++;
                        break;
                    } else {
                        break;
                    }
                }
                count += tempCount;

                // åæ–¹å‘å»¶ä¼¸
                tempCount = 0;
                for (let k = 1; k < 5; k++) {
                    const nx = x - k * dx;
                    const ny = y - k * dy;
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === player) {
                        tempCount++;
                    } else if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === 0) {
                        openEnds++;
                        break;
                    } else {
                        break;
                    }
                }
                count += tempCount;
                count++; // åŠ ä¸Šå½“å‰å­

                // è¯„åˆ†
                if (count >= 5) {
                    pointScore += player === 2 ? weights['5'] : -weights['5'];
                } else if (count === 4) {
                    if (openEnds === 2) {
                        pointScore += player === 2 ? weights['æ´»4'] : -weights['æ´»4'];
                    } else if (openEnds === 1) {
                        pointScore += player === 2 ? weights['å†²4'] : -weights['å†²4'];
                    }
                } else if (count === 3) {
                    if (openEnds === 2) {
                        pointScore += player === 2 ? weights['æ´»3'] : -weights['æ´»3'];
                    } else if (openEnds === 1) {
                        pointScore += player === 2 ? weights['çœ 3'] : -weights['çœ 3'];
                    }
                }
                // ... å¿½ç•¥ 2 è¿å­ï¼Œä»¥ä¿æŒç®€å•å’Œé€Ÿåº¦ ...
            }

            return pointScore;
        }
        
        // --- è®¡æ—¶å™¨åŠŸèƒ½ ---
        function startTimer() {
            startTime = new Date();
            timerInterval = setInterval(() => {
                const elapsed = new Date() - startTime;
                timerDisplay.textContent = formatTime(elapsed);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        // --- UI æ›´æ–°å‡½æ•° ---
        function updateCurrentPlayerDisplay() {
            const isBlack = currentPlayer === 1;
            currentPlayerSpan.textContent = isBlack ? 'é»‘å­ (Black)' : 'ç™½å­ (White)';
            currentPlayerSpan.style.color = isBlack ? '#000000' : '#ffffff';
            currentPlayerSpan.style.backgroundColor = isBlack ? '#ffffff' : '#000000';
            currentPlayerSpan.style.padding = '2px 5px';
            currentPlayerSpan.style.borderRadius = '3px';
        }

        function updateLastPositionDisplay(x, y) {
            // å°†åæ ‡ (0,0) åˆ° (14,14) è½¬æ¢ä¸º A1 åˆ° O15 (ä¾‹å¦‚: (0,0) -> A1, (14,14) -> O15)
            const colChar = String.fromCharCode('A'.charCodeAt(0) + x);
            const rowNum = y + 1;
            lastPositionSpan.textContent = `${colChar}${rowNum}`;
        }

        function updateLastMoveMarker(x, y) {
            const cx = CELL_SIZE / 2 + x * CELL_SIZE;
            const cy = CELL_SIZE / 2 + y * CELL_SIZE;
            
            lastMoveMarker.style.left = `${cx}px`;
            lastMoveMarker.style.top = `${cy}px`;
            lastMoveMarker.style.display = 'block';
        }

        // --- äº‹ä»¶ç›‘å¬å™¨ ---
        
        // æ£‹ç›˜ç‚¹å‡»
        canvas.addEventListener('click', (event) => {
            if (isGameOver) return;
            
            // è·å–ç‚¹å‡»åœ¨ Canvas ä¸Šçš„ç›¸å¯¹åæ ‡
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX - rect.left;
            const clientY = event.clientY - rect.top;

            // æ¢ç®—æˆæ£‹ç›˜æ ¼å­çš„ç´¢å¼• (å››èˆäº”å…¥åˆ°æœ€è¿‘çš„äº¤å‰ç‚¹)
            const x = Math.round((clientX - CELL_SIZE / 2) / CELL_SIZE);
            const y = Math.round((clientY - CELL_SIZE / 2) / CELL_SIZE);

            // æ£€æŸ¥ç´¢å¼•æ˜¯å¦åœ¨èŒƒå›´å†…
            if (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {
                placePiece(x, y);
            }
        });

        // æ‚”æ£‹æŒ‰é’®
        undoBtn.addEventListener('click', undoMove);

        // å¼€å§‹/é‡æ–°å¼€å§‹æŒ‰é’®
        startBtn.addEventListener('click', () => {
            initBoard();
            startTimer();
        });

        // æ¨¡å¼åˆ‡æ¢
        gameModeSelect.addEventListener('change', () => {
            const isPVE = gameModeSelect.value === 'pve';
            aiDifficultySelect.style.display = isPVE ? 'block' : 'none';
            aiDifficultyLabel.style.display = isPVE ? 'block' : 'none';
            // æ¨¡å¼åˆ‡æ¢åï¼Œå¼ºåˆ¶é‡æ–°å¼€å§‹æ¸¸æˆ
            initBoard(); 
        });

        // æ¨¡æ€æ¡†å…³é—­
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            document.getElementById('modal').style.display = 'none';
            // èƒœåˆ©åç‚¹å‡»æŒ‰é’®ï¼Œå‡†å¤‡ä¸‹ä¸€å±€
            initBoard(); 
        });


        // åˆå§‹è®¾ç½®
        window.onload = initBoard;

    </script>

</body>
</html>