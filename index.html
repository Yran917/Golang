<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹ (Gomoku) - å¢å¼ºç‰ˆ ğŸ®</title>
    <style>
        /* ------------------- CSS æ ·å¼ ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; /* æµ…ç°è‰²èƒŒæ™¯ */
            color: #333;
        }

        .main-container {
            display: flex;
            background-color: #fff;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            border-radius: 12px;
            overflow: hidden;
            max-width: 900px;
            /* éšè—æ¸¸æˆç•Œé¢ï¼Œé»˜è®¤æ˜¾ç¤ºèœå• */
            display: none; 
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        /* æ£‹ç›˜åŒºåŸŸ */
        #board-area {
            padding: 20px;
            background-color: #e0ac69; /* ç»å…¸æ£‹ç›˜æœ¨çº¹è‰² */
            position: relative;
        }

        #gobang-board {
            /* æ£‹ç›˜èƒŒæ™¯è‰² */
            background-color: #e4c489; 
            border: 2px solid #333;
            cursor: pointer;
            display: block;
        }

        /* ä¾§è¾¹æ§åˆ¶é¢æ¿ */
        .control-panel {
            width: 250px;
            padding: 30px;
            background-color: #2c3e50; /* æ·±è‰²èƒŒæ™¯ */
            color: #ecf0f1; /* æµ…è‰²æ–‡å­— */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .section h3 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #3498db;
        }

        /* æŒ‰é’®æ ·å¼ */
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            display: inline-block;
            font-size: 16px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.1s;
            width: 100%;
        }

        button:hover {
            background-color: #2980b9;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }

        /* çŠ¶æ€ä¿¡æ¯ */
        .status-info p {
            margin: 8px 0;
            font-size: 1.1em;
        }

        .status-info strong {
            color: #f1c40f;
        }

        #timer {
            font-size: 1.5em;
            color: #e74c3c;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
        }
        
        /* æœ€åçš„è½å­æ ‡è®° */
        .last-move-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #e74c3c; /* çº¢è‰² */
            border: 1px solid #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* ä¸å½±å“ç‚¹å‡» */
            z-index: 10;
        }

        /* èœå•ç•Œé¢ */
        #menu-screen {
            background-color: #fff;
            padding: 50px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 300px;
        }

        #menu-screen button {
            margin: 15px 0;
            padding: 15px 30px;
            font-size: 1.2em;
        }

        /* æ¨¡æ€æ¡†/ç»“æœæ˜¾ç¤º */
        .modal {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #fff;
            padding: 30px 50px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            color: #333;
        }
    </style>
</head>
<body>
    
    <div id="menu-screen">
        <h1>äº”å­æ£‹æ¨¡å¼é€‰æ‹©</h1>
        <button id="start-pve">äººæœºå¯¹æˆ˜ (å…ˆæ‰‹é»‘æ£‹)</button>
        <button id="start-pvp">äººäººå¯¹æˆ˜ (é»‘æ£‹å…ˆæ‰‹)</button>
    </div>

    <div class="main-container" id="game-container">
        
        <div id="board-area">
            <canvas id="gobang-board" width="600" height="600"></canvas>
            <div id="last-move-marker" class="last-move-marker" style="display: none;"></div>
        </div>

        <div class="control-panel">
            <div>
                <div class="section">
                    <h3 id="game-mode-display">äººæœºå¯¹æˆ˜</h3>
                    <div id="timer">00:00</div>
                </div>

                <div class="section status-info">
                    <h3>çŠ¶æ€</h3>
                    <p>å½“å‰ç©å®¶: <strong id="current-player-display">é»‘æ£‹ (Black)</strong></p>
                    <p>è½å­ä½ç½®: <strong id="last-position-display">N/A</strong></p>
                    <p>æ¸¸æˆçŠ¶æ€: <strong id="game-status">æœªå¼€å§‹</strong></p>
                </div>
            </div>

            <div class="section">
                <h3>æ“ä½œ</h3>
                <button id="undo-button" disabled>æ‚”æ£‹ (Undo)</button>
                <button id="reset-button">é‡æ–°å¼€å§‹æœ¬å±€</button>
                <button id="back-to-menu-button">è¿”å›ä¸»èœå•</button>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-message"></h2>
            <p>æ€»ç”¨æ—¶: <span id="modal-time"></span></p>
            <button id="close-modal-btn">å¥½çš„ï¼Œè¿”å›èœå•</button>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒå˜é‡ ---
        const BOARD_SIZE = 15;
        const TILE_SIZE = 40; // æ¯ä¸ªæ ¼å­çš„è¾¹é•¿
        const PADDING = 20; // æ£‹ç›˜è¾¹è·

        let board = []; // 0:ç©º, 1:é»‘æ£‹(ç©å®¶), 2:ç™½æ£‹(AI/ç©å®¶2)
        let isGameOver = true;
        let currentPlayer = 1; // 1:é»‘æ£‹, 2:ç™½æ£‹
        let gameMode = 'pve'; // 'pve' æˆ– 'pvp'
        let moveHistory = []; // å­˜å‚¨è½å­å†å²: [{r, c, player}]

        let timerInterval;
        let startTime;

        const canvas = document.getElementById('gobang-board');
        const ctx = canvas.getContext('2d');

        // DOM å…ƒç´ å¼•ç”¨
        const gameContainer = document.getElementById('game-container');
        const menuScreen = document.getElementById('menu-screen');
        const modeDisplay = document.getElementById('game-mode-display');
        const currentPlayerDisplay = document.getElementById('current-player-display');
        const lastPositionDisplay = document.getElementById('last-position-display');
        const gameStatus = document.getElementById('game-status');
        const lastMoveMarker = document.getElementById('last-move-marker');
        const timerDisplay = document.getElementById('timer');
        const undoButton = document.getElementById('undo-button');
        const modal = document.getElementById('modal');
        const modalMessage = document.getElementById('modal-message');
        const modalTime = document.getElementById('modal-time');


        // --- UI/æ¨¡å¼åˆ‡æ¢ ---

        function showMenu() {
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            isGameOver = true;
            stopTimer();
        }

        function startGame(mode) {
            gameMode = mode;
            modeDisplay.textContent = mode === 'pve' ? 'äººæœºå¯¹æˆ˜ (PVE)' : 'äººäººå¯¹æˆ˜ (PVP)';
            
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            
            initGame();
            startTimer();
        }

        // --- æ¸¸æˆåˆå§‹åŒ–å’Œç»˜å›¾ ---

        function initGame() {
            isGameOver = false;
            currentPlayer = 1;
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            moveHistory = [];
            
            undoButton.disabled = true;
            lastMoveMarker.style.display = 'none';
            lastPositionDisplay.textContent = 'N/A';
            gameStatus.textContent = 'æ¸¸æˆä¸­...';
            
            updateCurrentPlayerDisplay();
            drawBoard();
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e4c489';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // ç»˜åˆ¶æ¨ªçº¿å’Œçºµçº¿
            for (let i = 0; i < BOARD_SIZE; i++) {
                let coord = PADDING + i * TILE_SIZE;
                // ç»˜åˆ¶çºµçº¿
                ctx.beginPath();
                ctx.moveTo(coord, PADDING);
                ctx.lineTo(coord, canvas.height - PADDING);
                ctx.stroke();

                // ç»˜åˆ¶æ¨ªçº¿
                ctx.beginPath();
                ctx.moveTo(PADDING, coord);
                ctx.lineTo(canvas.width - PADDING, coord);
                ctx.stroke();
            }

            // ç»˜åˆ¶æ£‹å­
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        drawPiece(r, c, board[r][c]);
                    }
                }
            }
            // ç»˜åˆ¶æ˜Ÿä½ (ç•¥ï¼Œå¯æ ¹æ®éœ€è¦æ·»åŠ )
        }

        function drawPiece(r, c, player) {
            const x = PADDING + c * TILE_SIZE;
            const y = PADDING + r * TILE_SIZE;
            const radius = TILE_SIZE / 2 - 2;

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);

            // å¢åŠ ç«‹ä½“æ„Ÿ
            const gradient = ctx.createRadialGradient(
                x - radius * 0.2, y - radius * 0.2, radius * 0.1,
                x, y, radius
            );
            if (player === 1) { // é»‘å­
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#000');
            } else { // ç™½å­
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ccc');
            }
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
        }

        // --- ç©å®¶äº¤äº’ ---
        canvas.addEventListener('click', function(event) {
            if (isGameOver || (gameMode === 'pve' && currentPlayer !== 1)) return; // PVEæ¨¡å¼ä¸‹ï¼Œåªæœ‰ç©å®¶1å¯æ“ä½œ

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // æ‰¾åˆ°æœ€è¿‘çš„äº¤å‰ç‚¹
            const c = Math.round((x - PADDING) / TILE_SIZE);
            const r = Math.round((y - PADDING) / TILE_SIZE);

            // æ£€æŸ¥æ˜¯å¦æœ‰æ•ˆè½å­
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === 0) {
                placePiece(r, c, currentPlayer); 
                
                if (!isGameOver && gameMode === 'pve' && currentPlayer === 2) {
                    // åˆ‡æ¢åˆ° AIï¼Œå¹¶å»¶è¿Ÿæ‰§è¡Œ
                    currentPlayerDisplay.textContent = 'AI æ€è€ƒä¸­...';
                    canvas.style.cursor = 'wait';
                    setTimeout(aiMove, 500); 
                } else if (!isGameOver) {
                    updateCurrentPlayerDisplay(); // PVPæ¨¡å¼ä¸‹ç›´æ¥åˆ‡æ¢
                }
            }
        });

        // --- æ¸¸æˆé€»è¾‘ ---

        function placePiece(r, c, player) {
            board[r][c] = player;
            moveHistory.push({ r, c, player }); // è®°å½•å†å²
            
            drawBoard();
            updateLastMoveMarker(r, c); // æ ‡è®°ä½ç½®
            updateLastPositionDisplay(r, c); // æ˜¾ç¤ºä½ç½®

            undoButton.disabled = false; // å¯ç”¨æ‚”æ£‹

            if (checkWin(r, c, player)) {
                gameOver(player);
            } else if (checkDraw()) {
                gameOver(0); // 0 ä»£è¡¨å¹³å±€
            } else {
                // åˆ‡æ¢ç©å®¶
                currentPlayer = player === 1 ? 2 : 1;
                // å¦‚æœæ˜¯PVPæ¨¡å¼ï¼Œç«‹å³æ›´æ–°æ˜¾ç¤ºï¼›å¦‚æœæ˜¯PVEï¼Œç­‰å¾…AI
                if (gameMode === 'pvp') {
                    updateCurrentPlayerDisplay();
                }
            }
        }

        function checkWin(r, c, player) {
            // æ£€æŸ¥èƒœè´Ÿé€»è¾‘ï¼ˆä¸åŸä»£ç ç›¸åŒï¼Œè¿™é‡Œä¿ç•™ï¼‰
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                for (let i = 1; i < 5; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function checkDraw() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        function gameOver(winner) {
            isGameOver = true;
            stopTimer();
            canvas.style.cursor = 'pointer'; // æ¢å¤å…‰æ ‡

            let message;
            if (winner === 1) {
                message = "æ­å–œï¼Œé»‘æ£‹è·èƒœ!";
            } else if (winner === 2) {
                message = gameMode === 'pve' ? "AI è·èƒœ!" : "æ­å–œï¼Œç™½æ£‹è·èƒœ!";
            } else {
                message = "å¹³å±€!";
            }

            gameStatus.textContent = "æ¸¸æˆç»“æŸ!";
            modalMessage.textContent = message;
            modalTime.textContent = formatTime(new Date() - startTime);
            modal.style.display = 'flex';
        }


        // --- æ‚”æ£‹åŠŸèƒ½ ---

        function undoMove() {
            if (isGameOver || moveHistory.length === 0) return;

            let stepsToUndo = gameMode === 'pve' ? 2 : 1; // PVEæ‚”ä¸¤æ­¥ï¼ŒPVPæ‚”ä¸€æ­¥

            for (let i = 0; i < stepsToUndo; i++) {
                if (moveHistory.length > 0) {
                    const lastMove = moveHistory.pop();
                    board[lastMove.r][lastMove.c] = 0;
                    currentPlayer = lastMove.player; // æ‚”æ£‹åï¼Œå›åˆ°ä¸Šä¸€æ‰‹ç©å®¶
                }
            }

            drawBoard();
            
            // æ›´æ–°çŠ¶æ€
            undoButton.disabled = moveHistory.length === 0;
            updateCurrentPlayerDisplay();
            
            if (moveHistory.length > 0) {
                const last = moveHistory[moveHistory.length - 1];
                updateLastMoveMarker(last.r, last.c);
                updateLastPositionDisplay(last.r, last.c);
            } else {
                lastMoveMarker.style.display = 'none';
                lastPositionDisplay.textContent = 'N/A';
            }
            
            // ç¡®ä¿åœ¨ PVE æ¨¡å¼ä¸‹ï¼Œæ‚”æ£‹åæ˜¯ç©å®¶å›åˆ
            if (gameMode === 'pve') {
                 currentPlayer = 1; 
                 updateCurrentPlayerDisplay();
            }
        }


        // --- è®¡æ—¶å™¨åŠŸèƒ½ ---

        function startTimer() {
            stopTimer();
            startTime = new Date();
            timerInterval = setInterval(() => {
                const elapsed = new Date() - startTime;
                timerDisplay.textContent = formatTime(elapsed);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        // --- UI æ›´æ–°å‡½æ•° ---

        function updateCurrentPlayerDisplay() {
            const isBlack = currentPlayer === 1;
            const playerText = isBlack ? 'é»‘æ£‹ (Black)' : 'ç™½æ£‹ (White)';
            
            currentPlayerDisplay.textContent = playerText;
            currentPlayerDisplay.style.color = isBlack ? '#000000' : '#ffffff';
            currentPlayerDisplay.style.backgroundColor = isBlack ? '#ffffff' : '#000000';
            currentPlayerDisplay.style.padding = '2px 5px';
            currentPlayerDisplay.style.borderRadius = '3px';
        }

        function updateLastPositionDisplay(r, c) {
            // å°† (r, c) è½¬æ¢ä¸ºæ£‹è°±åæ ‡ (ä¾‹å¦‚: (0,0) -> A1, (14,14) -> O15)
            const colChar = String.fromCharCode('A'.charCodeAt(0) + c);
            const rowNum = r + 1;
            lastPositionDisplay.textContent = `${colChar}${rowNum}`;
        }

        function updateLastMoveMarker(r, c) {
            const cx = PADDING + c * TILE_SIZE;
            const cy = PADDING + r * TILE_SIZE;
            
            lastMoveMarker.style.left = `${cx}px`;
            lastMoveMarker.style.top = `${cy}px`;
            lastMoveMarker.style.display = 'block';
        }

        // --- AI é€»è¾‘ (ä½¿ç”¨æ‚¨åŸæœ‰çš„é€»è¾‘) ---
        // (aiMove å’Œ evaluatePosition å‡½æ•°ä¸æ‚¨çš„åŸä»£ç åŸºæœ¬ç›¸åŒï¼Œå·²åˆå¹¶åˆ°ä¸»è„šæœ¬)

        function aiMove() {
            canvas.style.cursor = 'pointer'; // æ¢å¤å…‰æ ‡
            updateCurrentPlayerDisplay(); // AIå›åˆæ˜¾ç¤ºä¸ºç™½æ£‹

            let bestScore = -Infinity;
            let bestMove = null;

            // éå†æ‰€æœ‰ç©ºä½ï¼Œè¯„ä¼°å¾—åˆ†
            const candidateMoves = getCandidateMoves(2); // ä»…æœç´¢éç©ºæ£‹å­å‘¨å›´2æ ¼

            for (const { r, c } of candidateMoves) {
                
                // 1. è¯„ä¼°è‡ªå·±è½å­åçš„å¾—åˆ†
                board[r][c] = 2; // å°è¯• AI è‡ªå·±çš„æ£‹å­
                let score = evaluatePosition(r, c, 2); 
                board[r][c] = 0; // æ’¤é”€å°è¯•

                // 2. è¯„ä¼°é˜»æ­¢å¯¹æ‰‹ (ç©å®¶) è½å­çš„å¾—åˆ†
                board[r][c] = 1; // å°è¯•æ¨¡æ‹Ÿç©å®¶è½å­
                // ç»™é˜»æ­¢ç©å®¶çš„å¾—åˆ†æ›´é«˜çš„æƒé‡ (1.5å€)
                score += evaluatePosition(r, c, 1) * 1.5; 
                board[r][c] = 0; // æ’¤é”€å°è¯•

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { r, c };
                }
            }

            if (bestMove) {
                placePiece(bestMove.r, bestMove.c, 2); // AI å®é™…è½å­
            }
        }

        function getCandidateMoves(range) {
            const candidates = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        for (let dr = -range; dr <= range; dr++) {
                            for (let dc = -range; dc <= range; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                                    candidates.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
            }
            // å¦‚æœæ²¡æœ‰æ£‹å­ï¼Œåˆ™é»˜è®¤å¤©å…ƒ
            if (candidates.size === 0) {
                candidates.add('7,7');
            }
            return Array.from(candidates).map(c => {
                const [r, c_] = c.split(',').map(Number);
                return {r, c: c_};
            });
        }
        
        function evaluatePosition(r, c, player) {
            // (ä½¿ç”¨æ‚¨åŸæœ‰çš„è¯„ä¼°é€»è¾‘ï¼Œå·²åŒ…å«åœ¨ä¸»è„šæœ¬ä¸­)
            let score = 0;
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];

            for (const [dr, dc] of directions) {
                let consecutive = 0;
                let openEnds = 0; 
                
                // æ¨¡æ‹Ÿè½å­ï¼Œå¹¶ä»è¯¥ç‚¹å‘ä¸¤ç«¯æ£€æŸ¥
                
                // æ£€æŸ¥æ­£æ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            consecutive++;
                        } else if (board[nr][nc] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                // æ£€æŸ¥åæ–¹å‘
                for (let i = 1; i < 5; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            consecutive++;
                        } else if (board[nr][nc] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                
                // æƒå€¼èµ‹äºˆï¼ˆç¡®ä¿èƒ½èµ¢/é˜»æ­¢èµ¢çš„å¾—åˆ†æœ€é«˜ï¼‰
                consecutive++; // åŠ ä¸Šå½“å‰å­
                
                if (consecutive >= 5) {
                    score += 100000; // 5è¿å­å¿…èƒœ
                } else if (consecutive === 4) {
                    if (openEnds === 2) {
                         score += 50000; // æ´»å››
                    } else if (openEnds >= 1) {
                         score += 10000; // å†²å››/çœ å››
                    }
                } else if (consecutive === 3 && openEnds >= 2) {
                    score += 5000; // æ´»ä¸‰
                } else if (consecutive === 3 && openEnds >= 1) {
                    score += 1000; // å†²ä¸‰/çœ ä¸‰
                } else if (consecutive === 2 && openEnds >= 2) {
                    score += 500; // æ´»äºŒ
                }
            }
            return score;
        }


        // --- å¯åŠ¨å’Œäº‹ä»¶ç›‘å¬ ---

        // ä¸»èœå•æŒ‰é’®
        document.getElementById('start-pve').addEventListener('click', () => startGame('pve'));
        document.getElementById('start-pvp').addEventListener('click', () => startGame('pvp'));
        
        // æ¸¸æˆæ“ä½œæŒ‰é’®
        undoButton.addEventListener('click', undoMove);
        document.getElementById('reset-button').addEventListener('click', () => {
            initGame();
            startTimer(); // é‡æ–°å¼€å§‹æœ¬å±€ï¼Œè®¡æ—¶é‡æ–°å¼€å§‹
        });
        document.getElementById('back-to-menu-button').addEventListener('click', showMenu);
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            modal.style.display = 'none';
            showMenu(); // ç»“æŸåè¿”å›ä¸»èœå•
        });
        
        window.onload = showMenu; // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºä¸»èœå•
    </script>
</body>
</html>