<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äº”å­æ£‹ (Gomoku) - ç§»åŠ¨å¢å¼ºç‰ˆ ğŸ“±</title>
    <style>
        /* ------------------- CSS æ ·å¼ ------------------- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f4f8; 
            color: #333;
            /* ç¡®ä¿å…ƒç´ ä¸ä¼šæº¢å‡º */
            overflow-x: hidden; 
            box-sizing: border-box;
        }

        /* ç§»åŠ¨ç«¯é»˜è®¤å¸ƒå±€ï¼šä¸Šä¸‹å †å ï¼Œå æ®å…¨å±å®½åº¦ */
        .main-container {
            display: flex;
            flex-direction: column; /* é»˜è®¤å‚ç›´å †å  */
            background-color: #fff;
            box-shadow: none; /* ç§»åŠ¨ç«¯ä¸è®¾é˜´å½± */
            border-radius: 0; 
            overflow: hidden;
            width: 100%;
            max-width: 900px;
            min-height: 100vh; /* ç¡®ä¿å æ®æ•´ä¸ªå‚ç›´ç©ºé—´ */
            display: none; 
        }

        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        /* æ£‹ç›˜åŒºåŸŸ */
        #board-area {
            /* ç§»åŠ¨ç«¯è°ƒæ•´ï¼šæ£‹ç›˜å±…ä¸­ï¼Œä½¿ç”¨è§†å£å®½åº¦é™åˆ¶ */
            padding: 10px;
            background-color: #e0ac69;
            position: relative;
            width: 95vw; /* å æ®è§†å£å®½åº¦ */
            max-width: 600px; /* æœ€å¤§å®½åº¦é™åˆ¶ */
            margin: 10px auto; /* å±…ä¸­æ˜¾ç¤º */
            box-sizing: border-box;
        }

        #gobang-board {
            background-color: #e4c489; 
            border: 2px solid #333;
            cursor: pointer;
            display: block;
            /* ã€å…³é”®ã€‘Canvas å°ºå¯¸ç”± JS åŠ¨æ€è®¾ç½®ï¼Œä½† CSS ä¸Šè®©å®ƒå……æ»¡å®¹å™¨ */
            width: 100%; 
            height: 100%;
        }

        /* ä¾§è¾¹æ§åˆ¶é¢æ¿ */
        .control-panel {
            width: 100%; /* ç§»åŠ¨ç«¯å æ®å…¨å®½ */
            padding: 20px 15px; /* è°ƒæ•´å†…è¾¹è· */
            background-color: #2c3e50;
            color: #ecf0f1;
            box-sizing: border-box; /* ç¡®ä¿ padding ä¸å¢åŠ æ€»å®½åº¦ */
            order: 2; /* ç¡®ä¿åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºåœ¨æ£‹ç›˜ä¸‹æ–¹ */
        }
        
        /* çŠ¶æ€ä¿¡æ¯å’ŒæŒ‰é’®æ ·å¼ä¿æŒä¸å˜ */
        .section h3 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #3498db;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            text-align: center;
            display: block; /* ç¡®ä¿æŒ‰é’®å‚ç›´å †å  */
            font-size: 16px;
            margin: 8px auto; /* å±…ä¸­å’Œé—´è· */
            cursor: pointer;
            border-radius: 5px;
            width: 95%; /* æŒ‰é’®å®½åº¦ç¨å¾®æ”¶ç¼© */
        }
        /* ... å…¶ä»–æ ·å¼ä¿æŒä¸å˜ ... */
        
        /* èœå•ç•Œé¢ */
        #menu-screen {
            background-color: #fff;
            padding: 40px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 90%; /* ç§»åŠ¨ç«¯å®½åº¦ */
            max-width: 350px;
        }


        /* ------------------- æ¡Œé¢ç«¯åª’ä½“æŸ¥è¯¢ (å±å¹•å®½åº¦å¤§äº 768px æ—¶ç”Ÿæ•ˆ) ------------------- */
        @media (min-width: 768px) {
            .main-container {
                flex-direction: row; /* æ¢å¤å·¦å³åˆ†æ  */
                max-width: 900px;
                min-height: auto;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
                border-radius: 12px;
            }
            #board-area {
                width: auto; /* å®½åº¦ç”± Canvas å†³å®š */
                max-width: 600px;
                margin: 0;
                padding: 20px;
            }
            .control-panel {
                width: 250px; /* æ¢å¤å›ºå®šå®½åº¦ */
                padding: 30px;
                order: 0; /* æ¢å¤æ­£å¸¸é¡ºåº */
            }
            button {
                width: 100%; /* æ¢å¤æ»¡å®½åº¦ */
            }
        }
    </style>
</head>
<body>
    
    <div id="menu-screen">
        <h1>äº”å­æ£‹æ¨¡å¼é€‰æ‹©</h1>
        <button id="start-pve">äººæœºå¯¹æˆ˜ (å…ˆæ‰‹é»‘æ£‹)</button>
        <button id="start-pvp">äººäººå¯¹æˆ˜ (é»‘æ£‹å…ˆæ‰‹)</button>
    </div>

    <div class="main-container" id="game-container">
        
        <div id="board-area">
            <canvas id="gobang-board"></canvas>
            <div id="last-move-marker" class="last-move-marker" style="display: none;"></div>
        </div>

        <div class="control-panel">
            <div>
                <div class="section">
                    <h3 id="game-mode-display">äººæœºå¯¹æˆ˜</h3>
                    <div id="timer">00:00</div>
                </div>

                <div class="section status-info">
                    <h3>çŠ¶æ€</h3>
                    <p>å½“å‰ç©å®¶: <strong id="current-player-display">é»‘æ£‹ (Black)</strong></p>
                    <p>è½å­ä½ç½®: <strong id="last-position-display">N/A</strong></p>
                    <p>æ¸¸æˆçŠ¶æ€: <strong id="game-status">æœªå¼€å§‹</strong></p>
                </div>
            </div>

            <div class="section">
                <h3>æ“ä½œ</h3>
                <button id="undo-button" disabled>æ‚”æ£‹ (Undo)</button>
                <button id="reset-button">é‡æ–°å¼€å§‹æœ¬å±€</button>
                <button id="back-to-menu-button">è¿”å›ä¸»èœå•</button>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-message"></h2>
            <p>æ€»ç”¨æ—¶: <span id="modal-time"></span></p>
            <button id="close-modal-btn">å¥½çš„ï¼Œè¿”å›èœå•</button>
        </div>
    </div>

    <script>
        // --- æ ¸å¿ƒå˜é‡ (éƒ¨åˆ†æ”¹ä¸ºåŠ¨æ€å˜é‡) ---
        const BOARD_SIZE = 15;
        let TILE_SIZE; // åŠ¨æ€è®¡ç®—
        let PADDING;   // åŠ¨æ€è®¡ç®—

        let board = []; 
        let isGameOver = true;
        let currentPlayer = 1; 
        let gameMode = 'pve'; 
        let moveHistory = []; 

        let timerInterval;
        let startTime;

        const canvas = document.getElementById('gobang-board');
        const ctx = canvas.getContext('2d');

        // DOM å…ƒç´ å¼•ç”¨ (ä¿æŒä¸å˜)
        const gameContainer = document.getElementById('game-container');
        const menuScreen = document.getElementById('menu-screen');
        const modeDisplay = document.getElementById('game-mode-display');
        const currentPlayerDisplay = document.getElementById('current-player-display');
        const lastPositionDisplay = document.getElementById('last-position-display');
        const gameStatus = document.getElementById('game-status');
        const lastMoveMarker = document.getElementById('last-move-marker');
        const timerDisplay = document.getElementById('timer');
        const undoButton = document.getElementById('undo-button');
        const modal = document.getElementById('modal');
        const modalMessage = document.getElementById('modal-message');
        const modalTime = document.getElementById('modal-time');

        
        // ã€æ–°å¢ã€‘åŠ¨æ€è®¡ç®—æ£‹ç›˜å°ºå¯¸å’Œæ£‹å­å¤§å°
        function resizeGame() {
            const boardArea = document.getElementById('board-area');
            
            // ç¡®ä¿ DOM å…ƒç´ å·²åŠ è½½
            if (!boardArea) return; 

            // è·å–å®¹å™¨çš„å®é™…å®½åº¦ (å‡å»paddingï¼Œè¿™é‡Œä½¿ç”¨ clientWidth)
            const areaWidth = boardArea.clientWidth - 20; // å®¹å™¨å®½åº¦å‡å»CSS padding (10px*2)

            // Canvas å°ºå¯¸: ç¡®ä¿æ˜¯ 15x15ï¼Œæœ‰ 14 ä¸ªæ ¼å­é—´éš”
            // å°ºå¯¸å…¬å¼: CanvasSize = 2 * PADDING + (BOARD_SIZE - 1) * TILE_SIZE
            // ç®€å•æ–¹æ³•ï¼šè®©æ£‹å­å¤§å°ç­‰äº (å®¹å™¨å®½åº¦ / 15) 
            
            // è®¡ç®— TILE_SIZE å’Œ PADDING
            // æˆ‘ä»¬å¸Œæœ›æ£‹ç›˜çº¿ä¸çº¿ä¹‹é—´æ˜¯ 14 ä¸ª TILE_SIZE
            const desiredSize = Math.floor(areaWidth);
            
            // TILE_SIZE å†³å®šäº†çº¿ä¸çº¿ä¹‹é—´çš„è·ç¦»ï¼Œåº”åŸºäº 14 ä¸ªé—´éš”è®¡ç®—
            TILE_SIZE = Math.floor(desiredSize / (BOARD_SIZE + 1) ); // ç®€åŒ–è®¡ç®—ï¼Œç¨å¾®ç•™ç™½

            // PADDING å†³å®šäº†æ£‹ç›˜è¾¹ç¼˜çš„ç•™ç™½
            PADDING = TILE_SIZE; 
            
            // æœ€ç»ˆçš„ Canvas ç»˜åˆ¶å°ºå¯¸
            const finalCanvasSize = PADDING * 2 + (BOARD_SIZE - 1) * TILE_SIZE;
            
            // æ›´æ–° Canvas å±æ€§ï¼Œå¼ºåˆ¶é‡æ–°ç»˜åˆ¶
            canvas.width = finalCanvasSize;
            canvas.height = finalCanvasSize;

            // é‡æ–°ç»˜åˆ¶æ£‹ç›˜ï¼ˆå¦‚æœæ¸¸æˆæ˜¯æ´»åŠ¨çŠ¶æ€ï¼‰
            if (!isGameOver) {
                drawBoard();
                // ç¡®ä¿è½å­æ ‡è®°ä½ç½®ä¹Ÿæ›´æ–°
                if (moveHistory.length > 0) {
                    const last = moveHistory[moveHistory.length - 1];
                    updateLastMoveMarker(last.r, last.c); 
                }
            }
        }
        
        // --- æ¸¸æˆåˆå§‹åŒ–å’Œç»˜å›¾ (æ›´æ–°) ---

        function initGame() {
            // ã€æ–°å¢ã€‘åˆå§‹åŒ–æ—¶å…ˆè®¾ç½®å°ºå¯¸
            resizeGame(); 

            isGameOver = false;
            currentPlayer = 1;
            board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            moveHistory = [];
            
            undoButton.disabled = true;
            lastMoveMarker.style.display = 'none';
            lastPositionDisplay.textContent = 'N/A';
            gameStatus.textContent = 'æ¸¸æˆä¸­...';
            
            updateCurrentPlayerDisplay();
            drawBoard();
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#e4c489';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // ç»˜åˆ¶æ¨ªçº¿å’Œçºµçº¿
            for (let i = 0; i < BOARD_SIZE; i++) {
                let coord = PADDING + i * TILE_SIZE;
                // ç»˜åˆ¶çºµçº¿
                ctx.beginPath();
                ctx.moveTo(coord, PADDING);
                ctx.lineTo(coord, canvas.height - PADDING);
                ctx.stroke();

                // ç»˜åˆ¶æ¨ªçº¿
                ctx.beginPath();
                ctx.moveTo(PADDING, coord);
                ctx.lineTo(canvas.width - PADDING, coord);
                ctx.stroke();
            }

            // ç»˜åˆ¶æ£‹å­
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        drawPiece(r, c, board[r][c]);
                    }
                }
            }
        }

        function drawPiece(r, c, player) {
            const x = PADDING + c * TILE_SIZE;
            const y = PADDING + r * TILE_SIZE;
            // æ£‹å­åŠå¾„åŸºäºåŠ¨æ€ TILE_SIZE
            const radius = TILE_SIZE / 2 - 2; 

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);

            // ... ç»˜åˆ¶é€»è¾‘ä¿æŒä¸å˜ ...
            const gradient = ctx.createRadialGradient(
                x - radius * 0.2, y - radius * 0.2, radius * 0.1,
                x, y, radius
            );
            if (player === 1) { // é»‘å­
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#000');
            } else { // ç™½å­
                gradient.addColorStop(0, '#fff');
                gradient.addColorStop(1, '#ccc');
            }
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.stroke();
        }

        // --- ç©å®¶äº¤äº’ (é€‚é…ç§»åŠ¨ç«¯è§¦æ‘¸) ---
        canvas.addEventListener('click', function(event) {
            if (isGameOver || (gameMode === 'pve' && currentPlayer !== 1)) return; 

            const rect = canvas.getBoundingClientRect();
            // é€‚é…ç§»åŠ¨ç«¯ï¼Œä½¿ç”¨ event.clientX/Y (é€‚ç”¨äº click äº‹ä»¶)
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // æ ¹æ®æ–°çš„ TILE_SIZE/PADDING è®¡ç®—è½å­ä½ç½®
            const c = Math.round((x - PADDING) / TILE_SIZE);
            const r = Math.round((y - PADDING) / TILE_SIZE);

            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && board[r][c] === 0) {
                placePiece(r, c, currentPlayer); 
                
                if (!isGameOver && gameMode === 'pve' && currentPlayer === 2) {
                    currentPlayerDisplay.textContent = 'AI æ€è€ƒä¸­...';
                    canvas.style.cursor = 'wait';
                    setTimeout(aiMove, 500); 
                } else if (!isGameOver) {
                    updateCurrentPlayerDisplay(); 
                }
            }
        });
        
        // --- UI æ›´æ–°å‡½æ•° (æ›´æ–°è½å­æ ‡è®°é€»è¾‘) ---
        
        function updateLastMoveMarker(r, c) {
            // æ ¹æ®æ–°çš„ TILE_SIZE/PADDING é‡æ–°è®¡ç®—æ ‡è®°ä½ç½®
            const cx = PADDING + c * TILE_SIZE;
            const cy = PADDING + r * TILE_SIZE;
            
            lastMoveMarker.style.left = `${cx}px`;
            lastMoveMarker.style.top = `${cy}px`;
            lastMoveMarker.style.display = 'block';
            
            // ç¡®ä¿æ ‡è®°å°ºå¯¸ä¹Ÿæ˜¯å“åº”å¼çš„ (ä¾‹å¦‚ï¼Œæ˜¯ TILE_SIZE çš„ 25%)
            const markerSize = Math.max(10, TILE_SIZE * 0.25);
            lastMoveMarker.style.width = `${markerSize}px`;
            lastMoveMarker.style.height = `${markerSize}px`;
        }

        // ... (å…¶ä»–å‡½æ•°ï¼Œå¦‚ placePiece, checkWin, undoMove, aiMove, startTimer, formatTime ä¿æŒä¸å˜) ...
        
        // --- å¯åŠ¨å’Œäº‹ä»¶ç›‘å¬ (æ–°å¢ resize äº‹ä»¶) ---
        
        // æ¸¸æˆå¯åŠ¨å’Œæ¨¡å¼åˆ‡æ¢é€»è¾‘ä¿æŒä¸å˜
        document.getElementById('start-pve').addEventListener('click', () => startGame('pve'));
        document.getElementById('start-pvp').addEventListener('click', () => startGame('pvp'));
        document.getElementById('undo-button').addEventListener('click', undoMove);
        document.getElementById('reset-button').addEventListener('click', () => {
            initGame();
            startTimer();
        });
        document.getElementById('back-to-menu-button').addEventListener('click', showMenu);
        document.getElementById('close-modal-btn').addEventListener('click', () => {
            modal.style.display = 'none';
            showMenu();
        });
        
        // ã€æ–°å¢ã€‘ç›‘å¬çª—å£å¤§å°å˜åŒ–äº‹ä»¶ï¼Œç¡®ä¿æ—‹è½¬å±å¹•æˆ–æ”¹å˜çª—å£å¤§å°æ—¶æ£‹ç›˜èƒ½è‡ªé€‚åº”
        window.addEventListener('resize', () => {
            // å»¶è¿Ÿæ‰§è¡Œä»¥é˜²å¤šæ¬¡è§¦å‘
            setTimeout(resizeGame, 100); 
        });

        window.onload = () => {
            showMenu(); // é¡µé¢åŠ è½½å®Œæˆåæ˜¾ç¤ºä¸»èœå•
            resizeGame(); // é¦–æ¬¡åŠ è½½æ—¶è¿›è¡Œä¸€æ¬¡å°ºå¯¸è®¡ç®—
        };

        // *************** å¤åˆ¶åŸæœ‰çš„é€»è¾‘å‡½æ•° (å¦‚ placePiece, checkWin, aiMove, evaluatePosition ç­‰) åˆ°æ­¤ä½ç½® ***************
        // ç”±äºåŸä»£ç è¾ƒé•¿ï¼Œæ­¤å¤„çœç•¥äº†æœªä¿®æ”¹çš„é€»è¾‘å‡½æ•°ï¼Œè¯·ç¡®ä¿æ‚¨å°†å®ƒä»¬åŒ…å«è¿›æ¥ã€‚
        // ä»¥ä¸‹æ˜¯åŸä»£ç ä¸­çš„æ‰€æœ‰é€»è¾‘å‡½æ•°ï¼Œè¯·å°†å®ƒä»¬æ¥åœ¨ä¸Šé¢çš„ resizeGame() å’Œ updateLastMoveMarker() ä¹‹åã€‚
        
        // --- é€»è¾‘å‡½æ•° (ä»åŸä»£ç å¤åˆ¶) ---

        function showMenu() {
            gameContainer.style.display = 'none';
            menuScreen.style.display = 'block';
            isGameOver = true;
            stopTimer();
        }

        function startGame(mode) {
            gameMode = mode;
            modeDisplay.textContent = mode === 'pve' ? 'äººæœºå¯¹æˆ˜ (PVE)' : 'äººäººå¯¹æˆ˜ (PVP)';
            
            menuScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            
            initGame();
            startTimer();
        }

        // drawBoard, drawPiece, updateLastPositionDisplay, updateCurrentPlayerDisplay å·²åœ¨ä¸Šæ–‡ä¿®æ”¹

        function placePiece(r, c, player) {
            board[r][c] = player;
            moveHistory.push({ r, c, player }); // è®°å½•å†å²
            
            drawBoard();
            updateLastMoveMarker(r, c); // æ ‡è®°ä½ç½®
            updateLastPositionDisplay(r, c); // æ˜¾ç¤ºä½ç½®

            undoButton.disabled = false; // å¯ç”¨æ‚”æ£‹

            if (checkWin(r, c, player)) {
                gameOver(player);
            } else if (checkDraw()) {
                gameOver(0); // 0 ä»£è¡¨å¹³å±€
            } else {
                // åˆ‡æ¢ç©å®¶
                currentPlayer = player === 1 ? 2 : 1;
                // å¦‚æœæ˜¯PVPæ¨¡å¼ï¼Œç«‹å³æ›´æ–°æ˜¾ç¤ºï¼›å¦‚æœæ˜¯PVEï¼Œç­‰å¾…AI
                if (gameMode === 'pvp') {
                    updateCurrentPlayerDisplay();
                }
            }
        }

        function checkWin(r, c, player) {
            // æ£€æŸ¥èƒœè´Ÿé€»è¾‘ï¼ˆä¸åŸä»£ç ç›¸åŒï¼Œè¿™é‡Œä¿ç•™ï¼‰
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];
            for (const [dr, dc] of directions) {
                let count = 1;
                for (let i = 1; i < 5; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                for (let i = 1; i < 5; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === player) {
                        count++;
                    } else { break; }
                }
                if (count >= 5) return true;
            }
            return false;
        }

        function checkDraw() {
            return board.every(row => row.every(cell => cell !== 0));
        }

        function gameOver(winner) {
            isGameOver = true;
            stopTimer();
            canvas.style.cursor = 'pointer'; // æ¢å¤å…‰æ ‡

            let message;
            if (winner === 1) {
                message = "æ­å–œï¼Œé»‘æ£‹è·èƒœ!";
            } else if (winner === 2) {
                message = gameMode === 'pve' ? "AI è·èƒœ!" : "æ­å–œï¼Œç™½æ£‹è·èƒœ!";
            } else {
                message = "å¹³å±€!";
            }

            gameStatus.textContent = "æ¸¸æˆç»“æŸ!";
            modalMessage.textContent = message;
            modalTime.textContent = formatTime(new Date() - startTime);
            modal.style.display = 'flex';
        }


        function undoMove() {
            if (isGameOver || moveHistory.length === 0) return;

            let stepsToUndo = gameMode === 'pve' ? 2 : 1; 

            for (let i = 0; i < stepsToUndo; i++) {
                if (moveHistory.length > 0) {
                    const lastMove = moveHistory.pop();
                    board[lastMove.r][lastMove.c] = 0;
                    currentPlayer = lastMove.player; 
                }
            }

            drawBoard();
            
            undoButton.disabled = moveHistory.length === 0;
            updateCurrentPlayerDisplay();
            
            if (moveHistory.length > 0) {
                const last = moveHistory[moveHistory.length - 1];
                updateLastMoveMarker(last.r, last.c);
                updateLastPositionDisplay(last.r, last.c);
            } else {
                lastMoveMarker.style.display = 'none';
                lastPositionDisplay.textContent = 'N/A';
            }
            
            if (gameMode === 'pve') {
                 currentPlayer = 1; 
                 updateCurrentPlayerDisplay();
            }
        }


        function startTimer() {
            stopTimer();
            startTime = new Date();
            timerInterval = setInterval(() => {
                const elapsed = new Date() - startTime;
                timerDisplay.textContent = formatTime(elapsed);
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const seconds = String(totalSeconds % 60).padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        function updateCurrentPlayerDisplay() {
            const isBlack = currentPlayer === 1;
            const playerText = isBlack ? 'é»‘æ£‹ (Black)' : 'ç™½æ£‹ (White)';
            
            currentPlayerDisplay.textContent = playerText;
            currentPlayerDisplay.style.color = isBlack ? '#000000' : '#ffffff';
            currentPlayerDisplay.style.backgroundColor = isBlack ? '#ffffff' : '#000000';
            currentPlayerDisplay.style.padding = '2px 5px';
            currentPlayerDisplay.style.borderRadius = '3px';
        }

        function updateLastPositionDisplay(r, c) {
            const colChar = String.fromCharCode('A'.charCodeAt(0) + c);
            const rowNum = r + 1;
            lastPositionDisplay.textContent = `${colChar}${rowNum}`;
        }

        function aiMove() {
            canvas.style.cursor = 'pointer'; 
            updateCurrentPlayerDisplay(); 

            let bestScore = -Infinity;
            let bestMove = null;

            const candidateMoves = getCandidateMoves(2); 

            for (const { r, c } of candidateMoves) {
                
                board[r][c] = 2; 
                let score = evaluatePosition(r, c, 2); 
                board[r][c] = 0; 

                board[r][c] = 1; 
                score += evaluatePosition(r, c, 1) * 1.5; 
                board[r][c] = 0; 

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = { r, c };
                }
            }

            if (bestMove) {
                placePiece(bestMove.r, bestMove.c, 2); 
            }
        }

        function getCandidateMoves(range) {
            const candidates = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        for (let dr = -range; dr <= range; dr++) {
                            for (let dc = -range; dc <= range; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                                    candidates.add(`${nr},${nc}`);
                                }
                            }
                        }
                    }
                }
            }
            if (candidates.size === 0) {
                candidates.add('7,7');
            }
            return Array.from(candidates).map(c => {
                const [r, c_] = c.split(',').map(Number);
                return {r, c: c_};
            });
        }
        
        function evaluatePosition(r, c, player) {
            let score = 0;
            const directions = [ [0, 1], [1, 0], [1, 1], [1, -1] ];

            for (const [dr, dc] of directions) {
                let consecutive = 0;
                let openEnds = 0; 
                
                for (let i = 1; i < 5; i++) {
                    const nr = r + dr * i;
                    const nc = c + dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            consecutive++;
                        } else if (board[nr][nc] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }

                for (let i = 1; i < 5; i++) {
                    const nr = r - dr * i;
                    const nc = c - dc * i;
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        if (board[nr][nc] === player) {
                            consecutive++;
                        } else if (board[nr][nc] === 0) {
                            openEnds++;
                            break;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                
                consecutive++; 
                
                if (consecutive >= 5) {
                    score += 100000; 
                } else if (consecutive === 4) {
                    if (openEnds === 2) {
                         score += 50000; 
                    } else if (openEnds >= 1) {
                         score += 10000; 
                    }
                } else if (consecutive === 3 && openEnds >= 2) {
                    score += 5000; 
                } else if (consecutive === 3 && openEnds >= 1) {
                    score += 1000; 
                } else if (consecutive === 2 && openEnds >= 2) {
                    score += 500; 
                }
            }
            return score;
        }

        // *************** é€»è¾‘å‡½æ•°ç»“æŸ ***************

    </script>
</body>
</html>