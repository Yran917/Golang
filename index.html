<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>高级五子棋 - 竞技版</title>
    <style>
        :root {
            --board-color: #E6B37E;
            --line-color: #333;
            --primary-blue: #2196F3;
            --danger-red: #F44336;
            --accent-orange: #FF9800;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f2f5;
            margin: 0;
            padding: 10px;
            touch-action: manipulation;
        }

        /* 游戏容器 */
        #game-wrapper {
            width: 100%;
            max-width: 500px;
            background: white;
            padding: 15px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        /* 顶部状态栏 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: #fafafa;
            border-radius: 8px;
        }

        #timer {
            font-family: monospace;
            font-size: 1.2rem;
            color: var(--accent-orange);
            font-weight: bold;
        }

        #msg {
            font-weight: bold;
            font-size: 1.1rem;
            color: #444;
        }

        /* 棋盘 */
        #board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            aspect-ratio: 1/1;
            background-color: var(--board-color);
            border: 2px solid var(--line-color);
            position: relative;
            cursor: pointer;
        }

        .cell {
            border: 0.5px solid var(--line-color);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* 棋子样式 */
        .piece {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            z-index: 2;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .black { background: radial-gradient(circle at 30% 30%, #666, #000); }
        .white { background: radial-gradient(circle at 30% 30%, #fff, #ccc); border: 1px solid #999; }

        /* 最新落子标记 */
        .last-mark::after {
            content: "";
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            position: absolute;
            z-index: 3;
        }

        /* 控制按钮 */
        .controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-group {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }

        .btn-main { background: var(--primary-blue); color: white; }
        .btn-undo { background: var(--accent-orange); color: white; }
        .btn-exit { background: var(--danger-red); color: white; }
        button:disabled { background: #ccc; opacity: 0.7; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="status-bar">
        <div id="msg">请选择对战模式</div>
        <div id="timer">00:00</div>
    </div>

    <div id="board"></div>

    <div class="controls">
        <div id="menu-view" class="btn-group">
            <button class="btn-main" onclick="initGame('PVP')">人人对战</button>
            <button class="btn-main" onclick="showAILevels()">人机对战</button>
        </div>

        <div id="ai-view" class="btn-group hidden">
            <button onclick="initGame('PVE', 1)">简单</button>
            <button onclick="initGame('PVE', 2)">一般</button>
            <button onclick="initGame('PVE', 3)">困难</button>
            <button onclick="backToMenu()">返回</button>
        </div>

        <div id="play-view" class="btn-group hidden">
            <button class="btn-undo" id="undoBtn" onclick="undo()">悔棋</button>
            <button class="btn-exit" onclick="confirmExit()">退出当前对局</button>
        </div>
    </div>
</div>

<script>
    const BOARD_SIZE = 15;
    const WIN_SCORE = 10000000; // 定义一个极高的分数代表胜利
    const SEARCH_DEPTH = 3;     // AI 搜索深度
    
    let board = [];
    let history = [];
    let currentPlayer = 1; // 1: Black (Human), 2: White (AI)
    let isGameActive = false;
    let gameMode = 'PvP'; 
    let difficulty = 'Easy'; 
    
    let timerInterval = null;
    let startTime = 0;

    // ... (所有 DOM 元素获取保持不变)
    const boardGrid = document.getElementById('board-grid');
    const statusMessage = document.getElementById('status-message');
    const undoButton = document.getElementById('undo-button');
    const timerDisplay = document.getElementById('timer');
    const modeSelection = document.getElementById('mode-selection');
    const difficultyOptions = document.getElementById('difficulty-options');
    const gameActions = document.getElementById('game-actions');

    // --- 计时器和主流程控制 (保持不变) ---
    function startTimer() { /* ... (保持不变) ... */ }
    function stopTimer() { /* ... (保持不变) ... */ }
    function resetGameToMainMenu() { /* ... (保持不变) ... */ }
    function showDifficultyOptions() { /* ... (保持不变) ... */ }
    function startGame(mode, diff = 'Easy') { /* ... (保持不变) ... */ }
    function handleMove(r, c) { /* ... (保持不变) ... */ }
    function undoMove() { /* ... (保持不变) ... */ }
    function updateStatus(message) { /* ... (保持不变) ... */ }
    function createBoardUI() { /* ... (保持不变) ... */ }
    function renderPiece(r, c) { /* ... (保持不变) ... */ }
    function highlightLastMove() { /* ... (保持不变) ... */ }
    function checkWin(r, c) { /* ... (保持不变) ... */ }
    
    document.addEventListener('DOMContentLoaded', () => { /* ... (保持不变) ... */ });

    // --- AI 控制中心 ---

    function handleAI() {
        if (currentPlayer !== 2) return; 
        
        let move = null;
        if (difficulty === 'Easy') {
            move = getEasyAIMove();
        } else if (difficulty === 'Medium') {
            move = getMediumAIMove();
        } else if (difficulty === 'Hard') {
            // *** 调用全新的 Minimax 搜索逻辑 ***
            updateStatus("AI 正在思考...");
            setTimeout(() => {
                move = getHardAIMove();
                if (move) {
                    handleMove(move.r, move.c);
                }
            }, 100); // 增加少量延迟以显示思考状态
        }

        if (difficulty !== 'Hard' && move) {
            handleMove(move.r, move.c);
        }
    }

    // --- 简单和中等难度 (保持不变) ---
    function getEasyAIMove() { /* ... (保持不变) ... */ }
    function getMediumAIMove() { /* ... (保持不变) ... */ }
    function findCriticalMove(player) { /* ... (保持不变) ... */ }


    // =======================================================
    // === 3. 困难 AI：Minimax/Alpha-Beta 搜索实现 ===
    // =======================================================

    function getHardAIMove() {
        let bestScore = -Infinity;
        let bestMove = getEasyAIMove(); // 找不到最佳解时的后备方案

        let emptyCells = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] === 0) {
                    emptyCells.push({ r, c });
                }
            }
        }
        
        // 优化搜索：只搜索中心附近的空点，或已落子点周围的空点
        const candidateMoves = getSearchCandidates(emptyCells);

        for (const move of candidateMoves) {
            const r = move.r;
            const c = move.c;

            // 1. 模拟落子 (AI: 2)
            board[r][c] = 2;
            
            // 2. 启动 Minimax 搜索
            // depth-1, alpha=-Inf, beta=Inf, isMaximizingPlayer=false (下一层是人类)
            let score = minimax(board, SEARCH_DEPTH - 1, -Infinity, Infinity, false); 
            
            // 3. 恢复棋盘
            board[r][c] = 0;

            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }
        
        return bestMove;
    }

    // --- Minimax 核心函数 (递归) ---
    function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer) {
        
        // 1. 终止条件
        const score = evaluateBoard(currentBoard);
        
        // 达到搜索深度或已分胜负
        if (depth === 0 || Math.abs(score) >= WIN_SCORE) {
            return score;
        }

        if (isMaximizingPlayer) {
            // AI 玩家 (最大化得分)
            let maxEval = -Infinity;
            
            const candidateMoves = getSearchCandidates(getEmptyCells(currentBoard));

            for (const move of candidateMoves) {
                currentBoard[move.r][move.c] = 2; // 模拟 AI 落子
                
                let evaluation = minimax(currentBoard, depth - 1, alpha, beta, false); // 转向最小化层
                
                currentBoard[move.r][move.c] = 0; // 恢复
                
                maxEval = Math.max(maxEval, evaluation);
                alpha = Math.max(alpha, maxEval);
                if (beta <= alpha) break; // Alpha-Beta 剪枝
            }
            return maxEval;
            
        } else {
            // 人类玩家 (最小化 AI 得分)
            let minEval = Infinity;

            const candidateMoves = getSearchCandidates(getEmptyCells(currentBoard));

            for (const move of candidateMoves) {
                currentBoard[move.r][move.c] = 1; // 模拟 人类 落子
                
                let evaluation = minimax(currentBoard, depth - 1, alpha, beta, true); // 转向最大化层
                
                currentBoard[move.r][move.c] = 0; // 恢复
                
                minEval = Math.min(minEval, evaluation);
                beta = Math.min(beta, minEval);
                if (beta <= alpha) break; // Alpha-Beta 剪枝
            }
            return minEval;
        }
    }
    
    // --- 棋盘评估函数 (基于棋型评分) ---
    function evaluateBoard(currentBoard) {
        let aiScore = getScoreByPlayer(currentBoard, 2); // 评估 AI (2) 的得分
        let humanScore = getScoreByPlayer(currentBoard, 1); // 评估 人类 (1) 的得分
        
        // 最终得分 = AI 的优势 - 人类的威胁
        return aiScore - humanScore * 1.5; // 人类威胁的权重更高，迫使 AI 防守
    }
    
    // --- 核心评估逻辑：棋型评分 ---
    const SCORE_TABLE = {
        'FIVE': WIN_SCORE,
        'LIVE_FOUR': 100000,
        'DEAD_FOUR': 10000,
        'LIVE_THREE': 5000,
        'DEAD_THREE': 500,
        'LIVE_TWO': 100,
        'DEAD_TWO': 10,
    };

    function getScoreByPlayer(currentBoard, player) {
        let score = 0;
        const opponent = 3 - player;
        const directions = [ [1, 0], [0, 1], [1, 1], [1, -1] ];
        
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (currentBoard[r][c] === player) {
                    
                    // 检查每个方向的棋型
                    for (const [dr, dc] of directions) {
                        
                        // 简化评估：仅检查 5 个单位长度的线段
                        let line = '';
                        for (let i = -4; i <= 4; i++) {
                            const nr = r + i * dr, nc = c + i * dc;
                            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                line += currentBoard[nr][nc];
                            } else {
                                line += 'B'; // 边界
                            }
                        }
                        
                        // 将棋盘值转换为字符方便正则匹配：'1' (人), '2' (AI), '0' (空), 'B' (边界)
                        // 假设我们在评估 AI (2) 的得分，那么 AI 是 'P'，人是 'O'
                        const pattern = line.replace(/2/g, 'P').replace(/1/g, 'O').replace(/0/g, '-');
                        
                        // P: Player (AI), O: Opponent (Human), -: Empty
                        // 以下是核心评分规则，基于正则匹配简化的棋型：
                        
                        if (pattern.includes('PPPPP')) { // 活五/长连
                            return SCORE_TABLE.FIVE;
                        }
                        if (pattern.includes('-PPPP-')) { // 活四
                            score += SCORE_TABLE.LIVE_FOUR;
                        }
                        if (pattern.includes('OPPPP-') || pattern.includes('-PPPP-') || pattern.includes('PPPP-O')) { // 冲四
                             score += SCORE_TABLE.DEAD_FOUR;
                        }
                        if (pattern.includes('--PPP-') || pattern.includes('-PPP--')) { // 活三 (需要更精确的定义，这里是简化版)
                            score += SCORE_TABLE.LIVE_THREE;
                        }
                        // ... 可以继续添加更多棋型匹配 (如跳三, 活二等)
                    }
                }
            }
        }
        
        return score;
    }

    // --- 辅助函数：优化搜索点 ---
    function getEmptyCells(board) {
        let emptyCells = [];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] === 0) {
                    emptyCells.push({ r, c });
                }
            }
        }
        return emptyCells;
    }
    
    // 限制搜索范围，只在有棋子的周围 2 步范围内搜索，大幅提高性能
    function getSearchCandidates(emptyCells) {
        if (emptyCells.length === BOARD_SIZE * BOARD_SIZE) return emptyCells;
        
        const candidates = new Set();
        
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[r][c] !== 0) {
                    // 检查周围 2 步的空点
                    for (let dr = -2; dr <= 2; dr++) {
                        for (let dc = -2; dc <= 2; dc++) {
                            const nr = r + dr;
                            const nc = c + dc;
                            
                            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE && board[nr][nc] === 0) {
                                candidates.add(`${nr},${nc}`);
                            }
                        }
                    }
                }
            }
        }
        
        // 将 Set 转换回 {r, c} 数组
        return Array.from(candidates).map(key => {
            const [r, c] = key.split(',');
            return { r: parseInt(r), c: parseInt(c) };
        });
    }

</script>
</body>
</html>